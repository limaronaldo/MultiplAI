#!/usr/bin/env bun
/**
 * Webhook Test - Simulates GitHub webhook payload and tests batch processing
 * Run with: bun run scripts/test/test-webhook.ts [--batch|--milestone|--comment|--edge]
 */

import crypto from "crypto";
  defaultConfig,
  JobStatus,
} from "./core/types";
import type { Job } from "./integrations/db-jobs";
import { Orchestrator } from "./core/orchestrator";
import { TaskRunner } from "./core/task-runner";
import { db } from "./integrations/db";
const args = process.argv.slice(2);

// Sample GitHub issue labeled event payload
const payload = {
  action: "labeled",
import { Octokit } from "octokit";

// Validation helpers
const LABEL_REGEX = /^[a-zA-Z0-9_.-][a-zA-Z0-9_ .-]{0,49}$/;
const UUID_REGEX =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
const REPO_REGEX = /^[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+$/;

interface MilestoneIssue {
  number: number;
  title: string;
  body: string | null;
  labels: string[];
  milestone: {
    number: number;
    title: string;
  } | null;
}

export class GitHubClient {
  public octokit: Octokit;

  body: string | null;
  labels: string[];
}

export class GitHubClient {
  public octokit: Octokit;

# Get your API key at: Linear Settings â†’ API â†’ Personal API keys
LINEAR_API_KEY=
  return REPO_REGEX.test(repo);
}

function isValidLabel(label: string): boolean {
  return LABEL_REGEX.test(label);
}

// Inicializa Linear (pode falhar se nÃ£o configurado)
let linear: LinearService | null = null;
try {
  }
};

// Batch label detection test payload - multiple issues with auto-dev label
const batchPayload = {
  action: "labeled",
  label: {
    name: "batch-auto-dev"
  },
  issue: {
    number: 100,
    title: "Batch trigger issue",
    body: "This issue triggers batch processing for all auto-dev labeled issues",
    labels: [
      { name: "batch-auto-dev" },
      { name: "meta" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Milestone-based job creation test payload
const milestonePayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 50,
    title: "Milestone feature implementation",
    body: "Implement feature X as part of v1.0 milestone",
    labels: [
      { name: "auto-dev" },
      { name: "feature" }
    ],
    milestone: {
      number: 1,
      title: "v1.0 Release",
      description: "First major release",
      state: "open"
    },
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Comment posting test payload - issue_comment event
const commentPayload = {
  action: "created",
  comment: {
    id: 12345,
    body: "@autodev please implement this feature",
    user: {
      login: "limaronaldo"
    }
  },
  issue: {
    number: 25,
    title: "Feature request with comment trigger",
    body: "This feature should be implemented when mentioned in comments",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: No issues payload (empty repository)
const noIssuesPayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 1,
    title: "First issue in empty repo",
    body: "",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/empty-repo",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: Missing config payload
const missingConfigPayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 10,
    title: "Issue in repo without autodev config",
    body: "This repo has no .autodev/config.yml",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/no-config-repo",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: Failure scenario - invalid issue state
const failurePayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: -1, // Invalid issue number
    title: "", // Empty title
    body: null, // Null body
    labels: [
      { name: "auto-dev" }
    ],
    state: "closed" // Closed issue shouldn't trigger
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Test result tracking
interface TestResult {
  name: string;
  passed: boolean;
  response?: {
    status: number;
    body: unknown;
  };
  error?: string;
}

const testResults: TestResult[] = [];

// Helper to send webhook and track results
async function sendWebhook(
  testName: string,
  testPayload: object,
  eventType: string = "issues",
  expectedStatus: number = 200
): Promise<TestResult> {
  const payloadStr = JSON.stringify(testPayload);
  const sig = WEBHOOK_SECRET ? generateSignature(WEBHOOK_SECRET, payloadStr) : "";

  try {
    const response = await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-GitHub-Event": eventType,
        "X-GitHub-Delivery": crypto.randomUUID(),
        "X-Hub-Signature-256": sig,
        "User-Agent": "GitHub-Hookshot/test"
      },
      body: payloadStr,
    });

    let body: unknown;
    try {
      body = await response.json();
    } catch {
      body = await response.text();
    }

    const passed = response.status === expectedStatus;
    return {
      name: testName,
      passed,
      response: {
        status: response.status,
        body
      }
    };
  } catch (error) {
    return {
      name: testName,
      passed: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

// Run all batch processing tests
async function runBatchTests(): Promise<void> {
  console.log("\nðŸ§ª Running Batch Processing Tests\n");
  console.log("=".repeat(60));

  // Test 1: Batch label detection
  console.log("\nðŸ“‹ Test 1: Batch Label Detection");
  console.log("   Sending batch-auto-dev labeled issue...");
  const batchResult = await sendWebhook("Batch Label Detection", batchPayload);
  testResults.push(batchResult);
  logTestResult(batchResult);

  // Test 2: Label-based job creation
  console.log("\nðŸ“‹ Test 2: Label-Based Job Creation");
  console.log("   Sending auto-dev labeled issue...");
  const labelResult = await sendWebhook("Label-Based Job Creation", payload);
  testResults.push(labelResult);
  logTestResult(labelResult);

  // Test 3: Milestone-based job creation
  console.log("\nðŸ“‹ Test 3: Milestone-Based Job Creation");
  console.log("   Sending issue with milestone...");
  const milestoneResult = await sendWebhook("Milestone-Based Job Creation", milestonePayload);
  testResults.push(milestoneResult);
  logTestResult(milestoneResult);

  // Test 4: Automatic comment posting (issue_comment event)
  console.log("\nðŸ“‹ Test 4: Automatic Comment Posting");
  console.log("   Sending issue_comment event...");
  const commentResult = await sendWebhook("Automatic Comment Posting", commentPayload, "issue_comment");
  testResults.push(commentResult);
  logTestResult(commentResult);

  // Print summary
  printTestSummary();
}

// Run edge case tests
async function runEdgeCaseTests(): Promise<void> {
  console.log("\nðŸ§ª Running Edge Case Tests\n");
  console.log("=".repeat(60));

  // Test 5: No issues / empty repo
  console.log("\nðŸ“‹ Test 5: Empty Repository (No Issues)");
  console.log("   Sending issue from empty repo...");
  const noIssuesResult = await sendWebhook("Empty Repository", noIssuesPayload);
  testResults.push(noIssuesResult);
  logTestResult(noIssuesResult);

  // Test 6: Missing config
  console.log("\nðŸ“‹ Test 6: Missing Config");
  console.log("   Sending issue from repo without config...");
  const missingConfigResult = await sendWebhook("Missing Config", missingConfigPayload);
  testResults.push(missingConfigResult);
  logTestResult(missingConfigResult);

  // Test 7: Failure scenario - invalid data
  console.log("\nðŸ“‹ Test 7: Failure Scenario (Invalid Data)");
  console.log("   Sending invalid issue data...");
  // This might return 200 (ignored) or 400 (validation error) depending on implementation
  const failureResult = await sendWebhook("Failure Scenario", failurePayload, "issues", 200);
  testResults.push(failureResult);
  logTestResult(failureResult);

  // Print summary
  printTestSummary();
}

// Log individual test result
function logTestResult(result: TestResult): void {
  if (result.passed) {
    console.log(`   âœ… ${result.name}: PASSED`);
    if (result.response) {
      console.log(`      Status: ${result.response.status}`);
      console.log(`      Response: ${JSON.stringify(result.response.body, null, 2).split("\n").join("\n      ")}`);
    }
  } else {
    console.log(`   âŒ ${result.name}: FAILED`);
    if (result.error) {
      console.log(`      Error: ${result.error}`);
    }
    if (result.response) {
      console.log(`      Status: ${result.response.status}`);
      console.log(`      Response: ${JSON.stringify(result.response.body, null, 2).split("\n").join("\n      ")}`);
    }
  }
}

// Print test summary
function printTestSummary(): void {
  console.log("\n" + "=".repeat(60));
  console.log("ðŸ“Š Test Summary\n");

  const passed = testResults.filter(r => r.passed).length;
  const failed = testResults.filter(r => !r.passed).length;
  const total = testResults.length;

  console.log(`   Total:  ${total}`);
  console.log(`   Passed: ${passed} âœ…`);
  console.log(`   Failed: ${failed} ${failed > 0 ? "âŒ" : ""}`);
  console.log(`   Rate:   ${((passed / total) * 100).toFixed(1)}%`);

  if (failed > 0) {
    console.log("\n   Failed Tests:");
    testResults.filter(r => !r.passed).forEach(r => {
      console.log(`   - ${r.name}`);
    });
  }

  console.log("\n" + "=".repeat(60));
}

const payloadString = JSON.stringify(payload);

// Generate signature
# Validate diffs before committing (runs typecheck, default: true)
# Set to false to skip validation (faster but may commit broken code)
VALIDATE_DIFF=true

    .digest("hex");
}

// Check for test mode arguments
if (args.includes("--batch")) {
  await runBatchTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--edge")) {
  await runEdgeCaseTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--all")) {
  await runBatchTests();
  await runEdgeCaseTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--help") || args.includes("-h")) {
  console.log("Usage: bun run scripts/test/test-webhook.ts [options]");
  console.log("\nOptions:");
  console.log("  --batch     Run batch processing tests");
  console.log("  --edge      Run edge case tests");
  console.log("  --all       Run all tests");
  console.log("  --help, -h  Show this help message");
  console.log("\nWithout options, sends a single test webhook.");
  process.exit(0);
}

// Default behavior: single webhook test
const signature = WEBHOOK_SECRET ? generateSignature(WEBHOOK_SECRET, payloadString) : "";

console.log("ðŸ”— GitHub Webhook Test\n");
FLY_API_KEY=

      title: issue.title,
    }));
  }

  /**
   * List issues associated with a specific milestone
LOG_LEVEL=info

FLY_API_KEY=

# Batch Job Configuration
# Label to filter GitHub issues for batch processing
# Issues with this label will be picked up by the batch processor
BATCH_LABEL=batch-auto-dev
# Whether to group issues by milestone when processing batches
# When true, issues are processed in milestone order; when false, processed individually
BATCH_BY_MILESTONE=true
++ b/src/integrations/github.ts
   * @returns Array of issues with their details
   */
  async listIssuesByMilestone(
    owner: string,
    repo: string,
    milestoneNumber: number,
    label?: string,
  ): Promise<MilestoneIssue[]> {
    const issues: MilestoneIssue[] = [];
    let page = 1;
    const perPage = 100;

    try {
      while (true) {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
          repo,
          milestone: milestoneNumber.toString(),
          labels: label,
          state: "all",
          per_page: perPage,
          page,
        });

        for (const issue of response.data) {
          issues.push({
            number: issue.number,
            title: issue.title,
            body: issue.body ?? null,
            labels: issue.labels.map((l) =>
              typeof l === "string" ? l : l.name ?? "",
            ),
            milestone: issue.milestone
              ? { number: issue.milestone.number, title: issue.milestone.title }
              : null,
          });
        }

        if (response.data.length < perPage) break;
        page++;
      }
    } catch (error) {
      throw new Error(`Failed to list issues for milestone ${milestoneNumber}: ${error instanceof Error ? error.message : String(error)}`);
    }

    return issues;
  }
}
++ b/src/router.ts

  console.log(`[Job] Created job ${job.id} with ${taskIds.length} tasks`);

  // Post comment to the first issue in the job (the triggering issue)
  // This is done asynchronously to not block the response
  const triggeringIssue = issueNumbers[0];
  if (triggeringIssue) {
    // Fire and forget - don't await to keep response fast
    postJobCreatedComment(octokit, repo, triggeringIssue, job, taskIds.length).catch(
      (error) => {
        console.error(`[Job] Error in postJobCreatedComment:`, error);
      }
    );
  }

  return Response.json({
    ok: true,
    job,
++ b/scripts/test/test-webhook.ts
  /**
   * List open issues with a specific label
   * Handles pagination for repositories with many issues
   */
  async listIssuesByLabel(
    fullName: string,
    label: string,
  ): Promise<Issue[]> {
    const { owner, repo } = this.parseRepo(fullName);
    const allIssues: Issue[] = [];
    let page = 1;
    const perPage = 100;

    try {
      while (true) {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
  console.log(`[Webhook] Received ${event} event`);

  if (event === "issues") {
    // Handle labeled events for batch processing
    handleBatchLabelEvent(payload as GitHubIssueEvent);
    
    return handleIssueEvent(payload as GitHubIssueEvent);
  }


        const issues = response.data.map((issue) => ({
          number: issue.number,
          title: issue.title,
          body: issue.body ?? null,
          labels: issue.labels
            .map((label) => (typeof label === "string" ? label : label.name))
            .filter((name): name is string => name !== undefined),
        }));

  return Response.json({ ok: true, message: "Event ignored" });
});

/**
 * Handles batch trigger label events on issues.
 * When the BATCH_LABEL is added to an issue with a milestone,
 * this logs the relevant information for batch processing.
 */
function handleBatchLabelEvent(payload: GitHubIssueEvent): void {
  const { action, issue, repository, label } = payload;

  // Only process 'labeled' events
  if (action !== "labeled") {
    return;
  }

  // Get batch label from environment, with graceful fallback
  const batchLabel = process.env.BATCH_LABEL;
  
  if (!batchLabel) {
    // Log only once per startup would be ideal, but for now log at debug level
    // This is a graceful handling - batch processing simply won't trigger
    console.debug("[Webhook] BATCH_LABEL not configured - batch trigger disabled");
    return;
  }

  // Check if the label that was just added matches the batch trigger label
  // The 'label' field in the payload contains the label that was added
  const addedLabel = label?.name;
  
  if (!addedLabel) {
    console.debug("[Webhook] No label information in labeled event");
    return;
  }

  if (addedLabel !== batchLabel) {
    console.debug(`[Webhook] Label '${addedLabel}' does not match BATCH_LABEL '${batchLabel}'`);
    return;
  }

  // Extract owner and repo from full_name (format: "owner/repo")
  const [owner, repo] = repository.full_name.split("/");
  const issueNumber = issue.number;
  const milestone = issue.milestone;

  console.log(`[Webhook] Batch trigger label '${batchLabel}' detected on issue #${issueNumber}`);
  console.log(`[Webhook] Repository: ${owner}/${repo}`);
  console.log(`[Webhook] Issue number: ${issueNumber}`);
  console.log(`[Webhook] Issue title: ${issue.title}`);
  
  if (milestone) {
    console.log(`[Webhook] Milestone: ${milestone.title} (id: ${milestone.id}, number: ${milestone.number})`);
    console.log(`[Webhook] Milestone description: ${milestone.description || "(none)"}`);
    console.log(`[Webhook] Milestone due date: ${milestone.due_on || "(not set)"}`);
    console.log(`[Webhook] Milestone state: ${milestone.state}`);
  } else {
    console.log(`[Webhook] No milestone associated with issue #${issueNumber}`);
  }

  // Future: This is where batch job creation will be triggered
}

async function handleIssueEvent(payload: GitHubIssueEvent): Promise<Response> {
  const { action, issue, repository } = payload;

++ b/src/router.ts
        page++;
      }

      return allIssues;
    } catch (error: any) {
      console.error(`[GitHub] Error listing issues by label '${label}':`, error.message);
      throw new Error(`Failed to list issues with label '${label}': ${error.message}`);
    }
  }
      return Response.json({ ok: true, message: "Not an auto-dev issue" });
    }

    // Check for milestone batching
    const batchByMilestone = process.env.BATCH_BY_MILESTONE === "true";
    const milestone = issue.milestone;

    if (batchByMilestone && milestone) {
      console.log(
        `[Webhook] Milestone detected: "${milestone.title}" (id: ${milestone.id}) - batching enabled`,
      );

      // Fetch all issues in this milestone with auto-dev label
      const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
      const [owner, repoName] = repository.full_name.split("/");

      try {
        const { data: milestoneIssues } = await octokit.rest.issues.listForRepo(
          {
            owner,
            repo: repoName,
            milestone: String(milestone.number),
            state: "open",
            labels: defaultConfig.autoDevLabel,
            per_page: 100,
          },
        );

        console.log(
          `[Webhook] Found ${milestoneIssues.length} issues in milestone "${milestone.title}" with auto-dev label`,
        );

        if (milestoneIssues.length > 0) {
          // Create tasks for all milestone issues
          const taskIds: string[] = [];
          const errors: Array<{ issueNumber: number; error: string }> = [];

          for (const milestoneIssue of milestoneIssues) {
            // Skip PRs
            if (milestoneIssue.pull_request) continue;

            try {
              // Check if task already exists
              const existingTask = await db.getTaskByIssue(
                repository.full_name,
                milestoneIssue.number,
              );

              if (existingTask) {
                taskIds.push(existingTask.id);
                continue;
              }

              // Create new task
              const task = await db.createTask({
                githubRepo: repository.full_name,
                githubIssueNumber: milestoneIssue.number,
                githubIssueTitle: milestoneIssue.title,
                githubIssueBody: milestoneIssue.body || "",
                status: "NEW",
                attemptCount: 0,
                maxAttempts: defaultConfig.maxAttempts,
                isOrchestrated: false,
              });

              taskIds.push(task.id);
              console.log(
                `[Webhook] Created task ${task.id} for milestone issue #${milestoneIssue.number}`,
              );
            } catch (error) {
              errors.push({
                issueNumber: milestoneIssue.number,
                error: error instanceof Error ? error.message : "Unknown error",
              });
            }
          }

          if (taskIds.length > 0) {
            // Create job with all milestone tasks
            const job = await dbJobs.createJob({
              status: "pending",
              taskIds,
              githubRepo: repository.full_name,
              summary: {
                total: taskIds.length,
                completed: 0,
                failed: 0,
                inProgress: 0,
                prsCreated: [],
              },
            });

            console.log(
              `[Webhook] Created job ${job.id} for milestone "${milestone.title}" with ${taskIds.length} tasks`,
            );

            return Response.json({
              ok: true,
              message: `Created job for milestone "${milestone.title}"`,
              jobId: job.id,
              taskCount: taskIds.length,
              milestone: milestone.title,
              errors: errors.length > 0 ? errors : undefined,
            });
          }
        }
      } catch (error) {
        console.error(
          `[Webhook] Error fetching milestone issues, falling back to single issue mode:`,
          error,
        );
        // Fall through to single issue handling
      }
    } else if (batchByMilestone && !milestone) {
      console.log(
        `[Webhook] BATCH_BY_MILESTONE enabled but issue #${issue.number} has no milestone - processing as single issue`,
      );
    }

    // Verifica se jÃ¡ existe task para esta issue
    const existingTask = await db.getTaskByIssue(
      repository.full_name,
++ b/src/router.ts
 * Body: { repo: string, label: string, triggerIssueNumber?: number }
 * 
 * Creates a job containing all open issues in the repo that have the specified label.
 * If triggerIssueNumber is provided, ensures it's not duplicated in the job.
 */
route("POST", "/api/jobs/from-label", async (req) => {
  const body = await req.json();
  const { repo, label, triggerIssueNumber } = body as {
    repo: string;
    label: string;
    triggerIssueNumber?: number;
  };

  // Input validation
  if (!repo || !label) {
    console.log("[Job/Label] Missing required fields", { repo, label });
    return Response.json(
      { error: "Missing required fields: repo, label" },
      { status: 400 },
    );
  }

  if (!isValidRepo(repo)) {
    console.log("[Job/Label] Invalid repo format", { repo });
    return Response.json(
      { error: "Invalid repo format. Expected: owner/repo" },
      { status: 400 },
    );
  }

  if (!isValidLabel(label)) {
    console.log("[Job/Label] Invalid label format", { label });
    return Response.json(
      { error: "Invalid label format" },
      { status: 400 },
    );
  }

  if (triggerIssueNumber !== undefined && 
      (!Number.isInteger(triggerIssueNumber) || triggerIssueNumber <= 0)) {
    console.log("[Job/Label] Invalid trigger issue number", { triggerIssueNumber });
    return Response.json(
      { error: "triggerIssueNumber must be a positive integer" },
      { status: 400 },
    );
  }

  console.log(`[Job/Label] Creating job for repo=${repo} label=${label} trigger=#${triggerIssueNumber || 'none'}`);

  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
  const [owner, repoName] = repo.split("/");

  try {
    // Fetch all open issues with the specified label
    const { data: issues } = await octokit.rest.issues.listForRepo({
      owner,
      repo: repoName,
      state: "open",
      labels: label,
      per_page: 100,
    });

    // Filter out pull requests (GitHub API returns PRs in issues endpoint)
    const filteredIssues = issues.filter((i) => !i.pull_request);

    console.log(`[Job/Label] Found ${filteredIssues.length} issues with label '${label}'`);

    if (filteredIssues.length === 0) {
      console.log(`[Job/Label] No matching issues found for label '${label}'`);
      return Response.json({
        ok: true,
        message: `No open issues found with label '${label}'`,
        job: null,
        issueCount: 0,
      });
    }

    // Deduplicate: use Set to track issue numbers, ensuring trigger issue isn't added twice
    const issueNumbersSet = new Set<number>();
    for (const issue of filteredIssues) {
      issueNumbersSet.add(issue.number);
    }

    const issueNumbers = Array.from(issueNumbersSet);
    console.log(`[Job/Label] Processing ${issueNumbers.length} unique issues: ${issueNumbers.join(', ')}`);

    // Create tasks for each issue
    const taskIds: string[] = [];
    const errors: Array<{ issueNumber: number; error: string }> = [];

    for (const issueNumber of issueNumbers) {
      try {
        // Check if task already exists for this issue
        const existingTask = await db.getTaskByIssue(repo, issueNumber);
        if (existingTask) {
          console.log(`[Job/Label] Task already exists for issue #${issueNumber}: ${existingTask.id}`);
          taskIds.push(existingTask.id);
          continue;
        }

        // Find the issue data from our fetched list
        const issueData = filteredIssues.find((i) => i.number === issueNumber)!;

        // Create task
        const task = await db.createTask({
          githubRepo: repo,
          githubIssueNumber: issueNumber,
          githubIssueTitle: issueData.title,
          githubIssueBody: issueData.body || "",
          status: "NEW",
          attemptCount: 0,
          maxAttempts: defaultConfig.maxAttempts,
          isOrchestrated: false,
        });

        console.log(`[Job/Label] Created task ${task.id} for issue #${issueNumber}`);
        taskIds.push(task.id);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error";
        console.error(`[Job/Label] Failed to create task for issue #${issueNumber}:`, errorMsg);
        errors.push({
          issueNumber,
          error: errorMsg,
        });
      }
    }

    if (taskIds.length === 0) {
      console.error(`[Job/Label] Failed to create any tasks for label '${label}'`);
      return Response.json(
        { error: "Failed to create any tasks", details: errors },
        { status: 400 },
      );
    }

    // Create the job
    const job = await dbJobs.createJob({
      status: "pending",
      taskIds,
      githubRepo: repo,
      summary: {
        total: taskIds.length,
        completed: 0,
        failed: 0,
        inProgress: 0,
        prsCreated: [],
      },
    });

    console.log(`[Job/Label] Created job ${job.id} with ${taskIds.length} tasks for label '${label}'`);

    return Response.json({
      ok: true,
      message: `Created job with ${taskIds.length} issues matching label '${label}'`,
      job,
      issueCount: taskIds.length,
      triggerIssueIncluded: triggerIssueNumber ? issueNumbersSet.has(triggerIssueNumber) : undefined,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    console.error(`[Job/Label] Failed to create job for label '${label}':`, errorMsg);
    return Response.json(
      { error: "Failed to create job from label", details: errorMsg },
      { status: 500 },
    );
  }
});

/**
 * GET /api/jobs - List recent jobs
 */
++ b/src/router.ts
  return REPO_REGEX.test(repo);
}

/**
 * Posts a comment to a GitHub issue notifying about job creation
 * Handles failures gracefully without throwing
 */
async function postJobCreatedComment(
  octokit: Octokit,
  repo: string,
  issueNumber: number,
  job: Job,
  taskCount: number,
): Promise<void> {
  const [owner, repoName] = repo.split("/");
  
  // Build the job URL - use environment variable or default
  const baseUrl = process.env.APP_BASE_URL || "http://localhost:3000";
  const jobUrl = `${baseUrl}/api/jobs/${job.id}`;
  
  const commentBody = `## ðŸ¤– AutoDev Job Created

A batch processing job has been created from this issue.

| Detail | Value |
|--------|-------|
| **Job ID** | \`${job.id}\` |
| **Issues in Job** | ${taskCount} |
| **Status** | ${job.status} |

ðŸ“‹ [View Job Details](${jobUrl})

---
*This job will process the specified issues sequentially. Check the job details for progress updates.*`;

  try {
    await octokit.rest.issues.createComment({
      owner,
      repo: repoName,
      issue_number: issueNumber,
      body: commentBody,
    });
    console.log(`[Job] Posted creation comment to ${repo}#${issueNumber}`);
  } catch (error) {
    console.error(`[Job] Failed to post comment to ${repo}#${issueNumber}:`, error);
    // Don't throw - comment posting failure shouldn't break job creation
  }
}

// Inicializa Linear (pode falhar se nÃ£o configurado)
let linear: LinearService | null = null;
try {