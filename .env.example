import { Octokit } from "octokit";
import type { RestEndpointMethodTypes } from "@octokit/rest";
import parseDiff from "parse-diff";

interface CreatePRParams {
 */

import crypto from "crypto";
  defaultConfig,
  JobStatus,
} from "./core/types";
import type { Job } from "./integrations/db-jobs";
import { Orchestrator } from "./core/orchestrator";
import { TaskRunner } from "./core/task-runner";
import { db } from "./integrations/db";
const args = process.argv.slice(2);

  errorSummary?: string;
}

interface MilestoneIssue {
  number: number;
  title: string;
  state: string;
  labels: string[];
  milestone: {
    number: number;
    title: string;
  } | null;
}

export class GitHubClient {
  public octokit: Octokit;

  url: string;
}

export class GitHubClient {
  public octokit: Octokit;

const UUID_REGEX =
  /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
const REPO_REGEX = /^[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+$/;

interface MilestoneIssue {
  number: number;
  title: string;
  body: string | null;
  labels: string[];
  milestone: {
    number: number;
    title: string;
  } | null;
}

export class GitHubClient {
  public octokit: Octokit;

  body: string | null;
  labels: string[];
}

export class GitHubClient {
  public octokit: Octokit;

# Get your API key at: Linear Settings â†’ API â†’ Personal API keys
LINEAR_API_KEY=
  return REPO_REGEX.test(repo);
}

function isValidLabel(label: string): boolean {
  return LABEL_REGEX.test(label);
}

// Inicializa Linear (pode falhar se nÃ£o configurado)
let linear: LinearService | null = null;
try {
  }
# Label to filter GitHub issues for batch processing
BATCH_LABEL=batch-auto-dev
# Whether to group issues by milestone when processing batches
BATCH_BY_MILESTONE=false

# Auto-Dev Label Configuration
# Label that triggers automatic development workflow when added to issues
# When an issue receives this label, the system will automatically:
# 1. Analyze the issue and create an implementation plan
# 2. Generate code changes as a pull request
AUTO_DEV_LABEL=auto-dev
++ b/src/integrations/github.ts
  label: {
    name: "batch-auto-dev"
  },
  issue: {
    number: 100,
    title: "Batch trigger issue",
    body: "This issue triggers batch processing for all auto-dev labeled issues",
    labels: [
      { name: "batch-auto-dev" },
      { name: "meta" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Milestone-based job creation test payload
const milestonePayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 50,
    title: "Milestone feature implementation",
    body: "Implement feature X as part of v1.0 milestone",
    labels: [
      { name: "auto-dev" },
      { name: "feature" }
    ],
    milestone: {
      number: 1,
      title: "v1.0 Release",
      description: "First major release",
      state: "open"
    },
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Comment posting test payload - issue_comment event
const commentPayload = {
  action: "created",
  comment: {
    id: 12345,
    body: "@autodev please implement this feature",
    user: {
      login: "limaronaldo"
    }
  },
  issue: {
    number: 25,
    title: "Feature request with comment trigger",
    body: "This feature should be implemented when mentioned in comments",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: No issues payload (empty repository)
const noIssuesPayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 1,
    title: "First issue in empty repo",
    body: "",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/empty-repo",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: Missing config payload
const missingConfigPayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: 10,
    title: "Issue in repo without autodev config",
    body: "This repo has no .autodev/config.yml",
    labels: [
      { name: "auto-dev" }
    ],
    state: "open"
  },
  repository: {
    full_name: "limaronaldo/no-config-repo",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Edge case: Failure scenario - invalid issue state
const failurePayload = {
  action: "labeled",
  label: {
    name: "auto-dev"
  },
  issue: {
    number: -1, // Invalid issue number
    title: "", // Empty title
    body: null, // Null body
    labels: [
      { name: "auto-dev" }
    ],
    state: "closed" // Closed issue shouldn't trigger
  },
  repository: {
    full_name: "limaronaldo/autodev-test",
    default_branch: "main"
  },
  sender: {
    login: "limaronaldo"
  }
};

// Test result tracking
interface TestResult {
  name: string;
  passed: boolean;
  response?: {
    status: number;
    body: unknown;
  };
  error?: string;
}

const testResults: TestResult[] = [];

// Helper to send webhook and track results
async function sendWebhook(
  testName: string,
  testPayload: object,
  eventType: string = "issues",
  expectedStatus: number = 200
): Promise<TestResult> {
  const payloadStr = JSON.stringify(testPayload);
  const sig = WEBHOOK_SECRET ? generateSignature(WEBHOOK_SECRET, payloadStr) : "";

  try {
    const response = await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-GitHub-Event": eventType,
        "X-GitHub-Delivery": crypto.randomUUID(),
        "X-Hub-Signature-256": sig,
        "User-Agent": "GitHub-Hookshot/test"
      },
      body: payloadStr,
    });

    let body: unknown;
    try {
      body = await response.json();
    } catch {
      body = await response.text();
    }

    const passed = response.status === expectedStatus;
    return {
      name: testName,
      passed,
      response: {
        status: response.status,
        body
      }
    };
  } catch (error) {
    return {
      name: testName,
      passed: false,
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

// Run all batch processing tests
async function runBatchTests(): Promise<void> {
  console.log("\nðŸ§ª Running Batch Processing Tests\n");
  console.log("=".repeat(60));

  // Test 1: Batch label detection
  console.log("\nðŸ“‹ Test 1: Batch Label Detection");
  console.log("   Sending batch-auto-dev labeled issue...");
  const batchResult = await sendWebhook("Batch Label Detection", batchPayload);
  testResults.push(batchResult);
  logTestResult(batchResult);

  // Test 2: Label-based job creation
  console.log("\nðŸ“‹ Test 2: Label-Based Job Creation");
  console.log("   Sending auto-dev labeled issue...");
  const labelResult = await sendWebhook("Label-Based Job Creation", payload);
  testResults.push(labelResult);
  logTestResult(labelResult);

  // Test 3: Milestone-based job creation
  console.log("\nðŸ“‹ Test 3: Milestone-Based Job Creation");
  console.log("   Sending issue with milestone...");
  const milestoneResult = await sendWebhook("Milestone-Based Job Creation", milestonePayload);
  testResults.push(milestoneResult);
  logTestResult(milestoneResult);

  // Test 4: Automatic comment posting (issue_comment event)
  console.log("\nðŸ“‹ Test 4: Automatic Comment Posting");
  console.log("   Sending issue_comment event...");
  const commentResult = await sendWebhook("Automatic Comment Posting", commentPayload, "issue_comment");
  testResults.push(commentResult);
  logTestResult(commentResult);

  // Print summary
  printTestSummary();
}

// Run edge case tests
async function runEdgeCaseTests(): Promise<void> {
  console.log("\nðŸ§ª Running Edge Case Tests\n");
  console.log("=".repeat(60));

  // Test 5: No issues / empty repo
  console.log("\nðŸ“‹ Test 5: Empty Repository (No Issues)");
  console.log("   Sending issue from empty repo...");
  const noIssuesResult = await sendWebhook("Empty Repository", noIssuesPayload);
  testResults.push(noIssuesResult);
  logTestResult(noIssuesResult);

  // Test 6: Missing config
  console.log("\nðŸ“‹ Test 6: Missing Config");
  console.log("   Sending issue from repo without config...");
  const missingConfigResult = await sendWebhook("Missing Config", missingConfigPayload);
  testResults.push(missingConfigResult);
  logTestResult(missingConfigResult);

  // Test 7: Failure scenario - invalid data
  console.log("\nðŸ“‹ Test 7: Failure Scenario (Invalid Data)");
  console.log("   Sending invalid issue data...");
  // This might return 200 (ignored) or 400 (validation error) depending on implementation
  const failureResult = await sendWebhook("Failure Scenario", failurePayload, "issues", 200);
  testResults.push(failureResult);
  logTestResult(failureResult);

  // Print summary
  printTestSummary();
}

// Log individual test result
function logTestResult(result: TestResult): void {
  if (result.passed) {
    console.log(`   âœ… ${result.name}: PASSED`);
    if (result.response) {
      console.log(`      Status: ${result.response.status}`);
      console.log(`      Response: ${JSON.stringify(result.response.body, null, 2).split("\n").join("\n      ")}`);
    }
  } else {
    console.log(`   âŒ ${result.name}: FAILED`);
    if (result.error) {
      console.log(`      Error: ${result.error}`);
    }
    if (result.response) {
      console.log(`      Status: ${result.response.status}`);
      console.log(`      Response: ${JSON.stringify(result.response.body, null, 2).split("\n").join("\n      ")}`);
    }
  }
}

// Print test summary
function printTestSummary(): void {
  console.log("\n" + "=".repeat(60));
  console.log("ðŸ“Š Test Summary\n");

  const passed = testResults.filter(r => r.passed).length;
  const failed = testResults.filter(r => !r.passed).length;
  const total = testResults.length;

  console.log(`   Total:  ${total}`);
  console.log(`   Passed: ${passed} âœ…`);
  console.log(`   Failed: ${failed} ${failed > 0 ? "âŒ" : ""}`);
  console.log(`   Rate:   ${((passed / total) * 100).toFixed(1)}%`);

  if (failed > 0) {
    console.log("\n   Failed Tests:");
    testResults.filter(r => !r.passed).forEach(r => {
      console.log(`   - ${r.name}`);
    });
  }

  console.log("\n" + "=".repeat(60));
}

const payloadString = JSON.stringify(payload);

// Generate signature
# Validate diffs before committing (runs typecheck, default: true)
# Set to false to skip validation (faster but may commit broken code)
VALIDATE_DIFF=true

    .digest("hex");
}

// Check for test mode arguments
if (args.includes("--batch")) {
  await runBatchTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--edge")) {
  await runEdgeCaseTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--all")) {
  await runBatchTests();
  await runEdgeCaseTests();
  process.exit(testResults.every(r => r.passed) ? 0 : 1);
}

if (args.includes("--help") || args.includes("-h")) {
  console.log("Usage: bun run scripts/test/test-webhook.ts [options]");
  console.log("\nOptions:");
  console.log("  --batch     Run batch processing tests");
  console.log("  --edge      Run edge case tests");
  console.log("  --all       Run all tests");
  console.log("  --help, -h  Show this help message");
  console.log("\nWithout options, sends a single test webhook.");
  process.exit(0);
}

// Default behavior: single webhook test
const signature = WEBHOOK_SECRET ? generateSignature(WEBHOOK_SECRET, payloadString) : "";

console.log("ðŸ”— GitHub Webhook Test\n");
FLY_API_KEY=

      title: issue.title,
    }));
  }

  /**
   * List issues associated with a specific milestone
LOG_LEVEL=info

FLY_API_KEY=

# Batch Job Configuration
# Label to filter GitHub issues for batch processing
# Issues with this label will be picked up by the batch processor
BATCH_LABEL=batch-auto-dev
# Whether to group issues by milestone when processing batches
# When true, issues are processed in milestone order; when false, processed individually
BATCH_BY_MILESTONE=true
++ b/src/integrations/github.ts
   * @returns Array of issues with their details
   */
  async listIssuesByMilestone(
    owner: string,
    repo: string,
    milestoneNumber: number,
    label?: string,
  ): Promise<MilestoneIssue[]> {
    const issues: MilestoneIssue[] = [];
    let page = 1;
    const perPage = 100;

    try {
      while (true) {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
          repo,
          milestone: milestoneNumber.toString(),
          labels: label,
          state: "all",
          per_page: perPage,
          page,
        });

        for (const issue of response.data) {
          issues.push({
            number: issue.number,
            title: issue.title,
            body: issue.body ?? null,
            labels: issue.labels.map((l) =>
              typeof l === "string" ? l : l.name ?? "",
            ),
            milestone: issue.milestone
              ? { number: issue.milestone.number, title: issue.milestone.title }
              : null,
          });
        }

        if (response.data.length < perPage) break;
        page++;
      }
    } catch (error) {
      throw new Error(`Failed to list issues for milestone ${milestoneNumber}: ${error instanceof Error ? error.message : String(error)}`);
    }

    return issues;
  }
}
++ b/src/router.ts

  console.log(`[Job] Created job ${job.id} with ${taskIds.length} tasks`);

  // Post comment to the first issue in the job (the triggering issue)
  // This is done asynchronously to not block the response
  const triggeringIssue = issueNumbers[0];
  if (triggeringIssue) {
    // Fire and forget - don't await to keep response fast
    postJobCreatedComment(octokit, repo, triggeringIssue, job, taskIds.length).catch(
      (error) => {
        console.error(`[Job] Error in postJobCreatedComment:`, error);
      }
    );
  }

  return Response.json({
    ok: true,
    job,
++ b/scripts/test/test-webhook.ts
  /**
   * List open issues with a specific label
   * Handles pagination for repositories with many issues
   */
  async listIssuesByLabel(
    fullName: string,
    label: string,
  ): Promise<Issue[]> {
    const { owner, repo } = this.parseRepo(fullName);
    const allIssues: Issue[] = [];
    let page = 1;
    const perPage = 100;

    try {
      while (true) {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
  console.log(`[Webhook] Received ${event} event`);

  if (event === "issues") {
    // Handle labeled events for batch processing
    handleBatchLabelEvent(payload as GitHubIssueEvent);
    
    return handleIssueEvent(payload as GitHubIssueEvent);
  }


        const issues = response.data.map((issue) => ({
          number: issue.number,
          title: issue.title,
          body: issue.body ?? null,
          labels: issue.labels
            .map((label) => (typeof label === "string" ? label : label.name))
            .filter((name): name is string => name !== undefined),
        }));

  return Response.json({ ok: true, message: "Event ignored" });
});

/**
 * Handles batch trigger label events on issues.
  async listIssuesByLabel(
    fullName: string,
    label: string,
  ): Promise<Array<{ number: number; title: string }>> {
    const { owner, repo } = this.parseRepo(fullName);

    console.log(`[GitHub] Fetching issues with label "${label}" from ${fullName}`);

    try {
      const issues: Array<{ number: number; title: string }> = [];

      // Use pagination to fetch all issues with the label
      const iterator = this.octokit.paginate.iterator(
        this.octokit.rest.issues.listForRepo,
        {
          owner,
          repo,
          labels: label,
          state: "open",
          per_page: 100,
        },
      );

      for await (const response of iterator) {
        for (const issue of response.data) {
          // Filter out pull requests (GitHub API returns PRs as issues too)
          if (!issue.pull_request) {
            issues.push({
              number: issue.number,
              title: issue.title,
            });
          }
        }
      }

      console.log(`[GitHub] Found ${issues.length} issues with label "${label}"`);
      return issues;
    } catch (error: any) {
      const message = error.message || String(error);
      throw new Error(
        `Failed to list issues with label "${label}" in ${fullName}: ${message}`,
      );
    }
  }
}
++ b/src/integrations/github.ts
  ): Promise<CommentResult> {
    // Validate required parameters
    if (!fullName || typeof fullName !== "string") {
      throw new Error("fullName is required and must be a string");
    }
    if (!issueNumber || typeof issueNumber !== "number" || issueNumber <= 0) {
      throw new Error("issueNumber is required and must be a positive number");
    }
    if (!body || typeof body !== "string" || body.trim() === "") {
      throw new Error("body is required and must be a non-empty string");
    }

    const { owner, repo } = this.parseRepo(fullName);

    const response = await this.octokit.rest.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body,
    });

    console.log(`[GitHub] Posted comment #${response.data.id} on issue #${issueNumber}`);

    return {
      id: response.data.id,
      url: response.data.html_url,
    };
  }
}
++ b/src/services/batch-job-creator.ts
  // Get batch label from environment, with graceful fallback
  const batchLabel = process.env.BATCH_LABEL;
  
  if (!batchLabel) {
    // Log only once per startup would be ideal, but for now log at debug level
    // This is a graceful handling - batch processing simply won't trigger
    console.debug("[Webhook] BATCH_LABEL not configured - batch trigger disabled");
    return;
  }

  // Check if the label that was just added matches the batch trigger label
  // The 'label' field in the payload contains the label that was added
  const addedLabel = label?.name;
  
  if (!addedLabel) {
    console.debug("[Webhook] No label information in labeled event");
    return;
  }

  if (addedLabel !== batchLabel) {
    console.debug(`[Webhook] Label '${addedLabel}' does not match BATCH_LABEL '${batchLabel}'`);
    return;
  }

  // Extract owner and repo from full_name (format: "owner/repo")
  const [owner, repo] = repository.full_name.split("/");
  const issueNumber = issue.number;
  const milestone = issue.milestone;

      title: issue.title,
    }));
  }

  /**
   * List issues associated with a specific milestone
   * @param fullName - Repository full name (owner/repo)
   * @param milestoneNumber - The milestone number to filter by
   * @param filterLabel - Optional label to further filter issues
   * @returns Array of issues with milestone information
   */
  async listIssuesByMilestone(
    fullName: string,
    milestoneNumber: number,
    filterLabel?: string,
  ): Promise<MilestoneIssue[]> {
    const { owner, repo } = this.parseRepo(fullName);
    const allIssues: MilestoneIssue[] = [];
    let page = 1;
    const perPage = 100;

    console.log(
      `[GitHub] Fetching issues for milestone #${milestoneNumber}${filterLabel ? ` with label "${filterLabel}"` : ""}`,
    );

    try {
      while (true) {
        const response = await this.octokit.rest.issues.listForRepo({
          owner,
          repo,
          milestone: String(milestoneNumber),
          labels: filterLabel,
          state: "all",
          per_page: perPage,
          page,
        });

        const issues = response.data.map((issue) => ({
          number: issue.number,
          title: issue.title,
          state: issue.state,
          labels: issue.labels.map((label) =>
            typeof label === "string" ? label : label.name || "",
          ),
          milestone: issue.milestone
            ? {
                number: issue.milestone.number,
                title: issue.milestone.title,
              }
            : null,
        }));

        allIssues.push(...issues);

        if (response.data.length < perPage) break;
        page++;
      }

      console.log(`[GitHub] Found ${allIssues.length} issues in milestone #${milestoneNumber}`);
      return allIssues;
    } catch (error: any) {
      throw new Error(
        `Failed to fetch issues for milestone #${milestoneNumber}: ${error.message}`,
      );
    }
  }
}
++ b/src/integrations/github.ts
  if (milestone) {
    console.log(`[Webhook] Milestone: ${milestone.title} (id: ${milestone.id}, number: ${milestone.number})`);
    console.log(`[Webhook] Milestone description: ${milestone.description || "(none)"}`);
    console.log(`[Webhook] Milestone due date: ${milestone.due_on || "(not set)"}`);
    console.log(`[Webhook] Milestone state: ${milestone.state}`);
  } else {
    console.log(`[Webhook] No milestone associated with issue #${issueNumber}`);
  }

  // Future: This is where batch job creation will be triggered
}

async function handleIssueEvent(payload: GitHubIssueEvent): Promise<Response> {
  const { action, issue, repository } = payload;

++ b/src/router.ts
        page++;
      }

      return allIssues;
    } catch (error: any) {
      console.error(`[GitHub] Error listing issues by label '${label}':`, error.message);
      throw new Error(`Failed to list issues with label '${label}': ${error.message}`);
    }
  }
      return Response.json({ ok: true, message: "Not an auto-dev issue" });
    }

    // Check for milestone batching
    const batchByMilestone = process.env.BATCH_BY_MILESTONE === "true";
    const milestone = issue.milestone;

    if (batchByMilestone && milestone) {
      console.log(
        `[Webhook] Milestone detected: "${milestone.title}" (id: ${milestone.id}) - batching enabled`,
      );

      // Fetch all issues in this milestone with auto-dev label
      const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
      const [owner, repoName] = repository.full_name.split("/");

      try {
        const { data: milestoneIssues } = await octokit.rest.issues.listForRepo(
          {
            owner,
            repo: repoName,
            milestone: String(milestone.number),
            state: "open",
            labels: defaultConfig.autoDevLabel,
            per_page: 100,
          },
        );

        console.log(
          `[Webhook] Found ${milestoneIssues.length} issues in milestone "${milestone.title}" with auto-dev label`,
        );

        if (milestoneIssues.length > 0) {
          // Create tasks for all milestone issues
          const taskIds: string[] = [];
          const errors: Array<{ issueNumber: number; error: string }> = [];

          for (const milestoneIssue of milestoneIssues) {
            // Skip PRs
            if (milestoneIssue.pull_request) continue;

            try {
              // Check if task already exists
              const existingTask = await db.getTaskByIssue(
                repository.full_name,
                milestoneIssue.number,
              );

              if (existingTask) {
                taskIds.push(existingTask.id);
                continue;
              }

              // Create new task
              const task = await db.createTask({
                githubRepo: repository.full_name,
                githubIssueNumber: milestoneIssue.number,
                githubIssueTitle: milestoneIssue.title,
                githubIssueBody: milestoneIssue.body || "",
                status: "NEW",
                attemptCount: 0,
                maxAttempts: defaultConfig.maxAttempts,
                isOrchestrated: false,
              });

              taskIds.push(task.id);
              console.log(
                `[Webhook] Created task ${task.id} for milestone issue #${milestoneIssue.number}`,
              );
            } catch (error) {
              errors.push({
                issueNumber: milestoneIssue.number,
                error: error instanceof Error ? error.message : "Unknown error",
              });
            }
          }

          if (taskIds.length > 0) {
            // Create job with all milestone tasks
            const job = await dbJobs.createJob({
              status: "pending",
              taskIds,
              githubRepo: repository.full_name,
              summary: {
                total: taskIds.length,
                completed: 0,
                failed: 0,
                inProgress: 0,
                prsCreated: [],
              },
            });

            console.log(
              `[Webhook] Created job ${job.id} for milestone "${milestone.title}" with ${taskIds.length} tasks`,
            );

            return Response.json({
              ok: true,
              message: `Created job for milestone "${milestone.title}"`,
              jobId: job.id,
              taskCount: taskIds.length,
              milestone: milestone.title,
              errors: errors.length > 0 ? errors : undefined,
            });
          }
        }
      } catch (error) {
        console.error(
          `[Webhook] Error fetching milestone issues, falling back to single issue mode:`,
          error,
        );
        // Fall through to single issue handling
      }
    } else if (batchByMilestone && !milestone) {
      console.log(
        `[Webhook] BATCH_BY_MILESTONE enabled but issue #${issue.number} has no milestone - processing as single issue`,
      );
    }

    // Verifica se jÃ¡ existe task para esta issue
    const existingTask = await db.getTaskByIssue(
      repository.full_name,
++ b/src/router.ts
 * Body: { repo: string, label: string, triggerIssueNumber?: number }
 * 
 * Creates a job containing all open issues in the repo that have the specified label.
 * If triggerIssueNumber is provided, ensures it's not duplicated in the job.
 */
route("POST", "/api/jobs/from-label", async (req) => {
  const body = await req.json();
  const { repo, label, triggerIssueNumber } = body as {
    repo: string;
    label: string;
    triggerIssueNumber?: number;
  };

  // Input validation
  if (!repo || !label) {
    console.log("[Job/Label] Missing required fields", { repo, label });
    return Response.json(
      { error: "Missing required fields: repo, label" },
      { status: 400 },
    );
  }

  if (!isValidRepo(repo)) {
    console.log("[Job/Label] Invalid repo format", { repo });
    return Response.json(
      { error: "Invalid repo format. Expected: owner/repo" },
      { status: 400 },
    );
  }

  if (!isValidLabel(label)) {
    console.log("[Job/Label] Invalid label format", { label });
    return Response.json(
      { error: "Invalid label format" },
      { status: 400 },
    );
  }

  if (triggerIssueNumber !== undefined && 
      (!Number.isInteger(triggerIssueNumber) || triggerIssueNumber <= 0)) {
    console.log("[Job/Label] Invalid trigger issue number", { triggerIssueNumber });
    return Response.json(
      { error: "triggerIssueNumber must be a positive integer" },
      { status: 400 },
    );
  }

  console.log(`[Job/Label] Creating job for repo=${repo} label=${label} trigger=#${triggerIssueNumber || 'none'}`);

  const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
  const [owner, repoName] = repo.split("/");

  try {
    // Fetch all open issues with the specified label
    const { data: issues } = await octokit.rest.issues.listForRepo({
      owner,
      repo: repoName,
      state: "open",
      labels: label,
      per_page: 100,
    });

    // Filter out pull requests (GitHub API returns PRs in issues endpoint)
    const filteredIssues = issues.filter((i) => !i.pull_request);

    console.log(`[Job/Label] Found ${filteredIssues.length} issues with label '${label}'`);

    if (filteredIssues.length === 0) {
      console.log(`[Job/Label] No matching issues found for label '${label}'`);
      return Response.json({
        ok: true,
        message: `No open issues found with label '${label}'`,
        job: null,
        issueCount: 0,
      });
    }

    // Deduplicate: use Set to track issue numbers, ensuring trigger issue isn't added twice
    const issueNumbersSet = new Set<number>();
    for (const issue of filteredIssues) {
      issueNumbersSet.add(issue.number);
    }

    const issueNumbers = Array.from(issueNumbersSet);
    console.log(`[Job/Label] Processing ${issueNumbers.length} unique issues: ${issueNumbers.join(', ')}`);

    // Create tasks for each issue
    const taskIds: string[] = [];
    const errors: Array<{ issueNumber: number; error: string }> = [];

    for (const issueNumber of issueNumbers) {
      try {
        // Check if task already exists for this issue
        const existingTask = await db.getTaskByIssue(repo, issueNumber);
        if (existingTask) {
          console.log(`[Job/Label] Task already exists for issue #${issueNumber}: ${existingTask.id}`);
          taskIds.push(existingTask.id);
          continue;
        }

        // Find the issue data from our fetched list
        const issueData = filteredIssues.find((i) => i.number === issueNumber)!;

        // Create task
        const task = await db.createTask({
          githubRepo: repo,
          githubIssueNumber: issueNumber,
          githubIssueTitle: issueData.title,
          githubIssueBody: issueData.body || "",
          status: "NEW",
          attemptCount: 0,
          maxAttempts: defaultConfig.maxAttempts,
          isOrchestrated: false,
        });

        console.log(`[Job/Label] Created task ${task.id} for issue #${issueNumber}`);
        taskIds.push(task.id);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : "Unknown error";
        console.error(`[Job/Label] Failed to create task for issue #${issueNumber}:`, errorMsg);
        errors.push({
          issueNumber,
          error: errorMsg,
        });
      }
    }

    if (taskIds.length === 0) {
      console.error(`[Job/Label] Failed to create any tasks for label '${label}'`);
      return Response.json(
        { error: "Failed to create any tasks", details: errors },
        { status: 400 },
      );
    }

    // Create the job
    const job = await dbJobs.createJob({
      status: "pending",
      taskIds,
      githubRepo: repo,
      summary: {
        total: taskIds.length,
        completed: 0,
        failed: 0,
        inProgress: 0,
        prsCreated: [],
      },
    });

    console.log(`[Job/Label] Created job ${job.id} with ${taskIds.length} tasks for label '${label}'`);

    return Response.json({
      ok: true,
      message: `Created job with ${taskIds.length} issues matching label '${label}'`,
      job,
      issueCount: taskIds.length,
      triggerIssueIncluded: triggerIssueNumber ? issueNumbersSet.has(triggerIssueNumber) : undefined,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    const errorMsg = error instanceof Error ? error.message : "Unknown error";
    console.error(`[Job/Label] Failed to create job for label '${label}':`, errorMsg);
    return Response.json(
      { error: "Failed to create job from label", details: errorMsg },
      { status: 500 },
    );
  }
});

/**
 * GET /api/jobs - List recent jobs
 */
++ b/src/router.ts
  return REPO_REGEX.test(repo);
}

/**
 * Posts a comment to a GitHub issue notifying about job creation
 * Handles failures gracefully without throwing
 */
async function postJobCreatedComment(
  octokit: Octokit,
  repo: string,
  issueNumber: number,
  job: Job,
  taskCount: number,
): Promise<void> {
  const [owner, repoName] = repo.split("/");
  
  // Build the job URL - use environment variable or default
  const baseUrl = process.env.APP_BASE_URL || "http://localhost:3000";
  const jobUrl = `${baseUrl}/api/jobs/${job.id}`;
  
  const commentBody = `## ðŸ¤– AutoDev Job Created

A batch processing job has been created from this issue.

| Detail | Value |
|--------|-------|
| **Job ID** | \`${job.id}\` |
| **Issues in Job** | ${taskCount} |
| **Status** | ${job.status} |

ðŸ“‹ [View Job Details](${jobUrl})

---
*This job will process the specified issues sequentially. Check the job details for progress updates.*`;

  try {
    await octokit.rest.issues.createComment({
      owner,
      repo: repoName,
      issue_number: issueNumber,
      body: commentBody,
    });
    console.log(`[Job] Posted creation comment to ${repo}#${issueNumber}`);
  } catch (error) {
    console.error(`[Job] Failed to post comment to ${repo}#${issueNumber}:`, error);
    // Don't throw - comment posting failure shouldn't break job creation
  }
}

// Inicializa Linear (pode falhar se nÃ£o configurado)
let linear: LinearService | null = null;
/**
 * Batch Job Creator Service
 * Creates batch processing jobs for multiple issues
 */

import { randomUUID } from 'crypto';

/**
 * Job status enum
 */
export type JobStatus = 'pending' | 'running' | 'completed' | 'failed';

/**
 * Batch job metadata
 */
export interface BatchJobMetadata {
  owner: string;
  repo: string;
  triggeredBy?: string;
  description?: string;
  priority?: 'low' | 'normal' | 'high';
}

/**
 * Batch job object returned by createBatchJob
 */
export interface BatchJob {
  id: string;
  issueNumbers: number[];
  issueCount: number;
  status: JobStatus;
  metadata: BatchJobMetadata;
  dashboardUrl: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Logger interface for job creation logging
 */
interface Logger {
  info(message: string, data?: Record<string, unknown>): void;
  error(message: string, data?: Record<string, unknown>): void;
}

const defaultLogger: Logger = {
  info: (message, data) => console.log(`[BatchJobCreator] ${message}`, data || ''),
  error: (message, data) => console.error(`[BatchJobCreator] ${message}`, data || ''),
};

/**
 * Creates a batch job for processing multiple issues
 *
 * @param issueNumbers - Array of issue numbers to process
 * @param metadata - Job metadata including owner, repo, and optional fields
 * @param logger - Optional logger instance
 * @returns BatchJob object with id and dashboard URL
 * @throws Error if issueNumbers is empty or metadata is invalid
 */
export function createBatchJob(
  issueNumbers: number[],
  metadata: BatchJobMetadata,
  logger: Logger = defaultLogger
): BatchJob {
  // Validate inputs
  if (!issueNumbers || issueNumbers.length === 0) {
    const error = new Error('issueNumbers array cannot be empty');
    logger.error('Failed to create batch job: empty issue numbers', { error: error.message });
    throw error;
  }

  if (!metadata.owner || !metadata.repo) {
    const error = new Error('metadata must include owner and repo');
    logger.error('Failed to create batch job: invalid metadata', { error: error.message });
    throw error;
  }

  // Generate unique job ID
  const jobId = randomUUID();
  const now = new Date();

  // Construct dashboard URL
  const dashboardUrl = `https://github.com/${metadata.owner}/${metadata.repo}/actions/runs/${jobId}`;

  const job: BatchJob = {
    id: jobId,
    issueNumbers: [...issueNumbers],
    issueCount: issueNumbers.length,
    status: 'pending',
    metadata,
    dashboardUrl,
    createdAt: now,
    updatedAt: now,
  };

  // Log job creation with issue count
  logger.info('Batch job created', {
    jobId: job.id,
    issueCount: job.issueCount,
    owner: metadata.owner,
    repo: metadata.repo,
    triggeredBy: metadata.triggeredBy,
  });

  return job;
}
++ b/src/services/batch-trigger-handler.ts
import { Octokit } from "@octokit/rest";
import { z } from "zod";

// Configuration schema
const ConfigSchema = z.object({
  BATCH_LABEL: z.string().default("claude-batch"),
  GITHUB_TOKEN: z.string(),
  GITHUB_OWNER: z.string(),
  GITHUB_REPO: z.string(),
});

type Config = z.infer<typeof ConfigSchema>;

// Issue type for batch processing
interface BatchIssue {
  number: number;
  title: string;
  url: string;
  labels: string[];
}

// Job result type
interface BatchJobResult {
  jobId: string;
  issueCount: number;
  issues: BatchIssue[];
  url: string;
  createdAt: string;
}

// Trigger result type
interface LabelTriggerResult {
  success: boolean;
  job?: BatchJobResult;
  error?: string;
  message: string;
}

function getConfig(): Config {
  return ConfigSchema.parse({
    BATCH_LABEL: process.env.BATCH_LABEL,
    GITHUB_TOKEN: process.env.GITHUB_TOKEN,
    GITHUB_OWNER: process.env.GITHUB_OWNER,
    GITHUB_REPO: process.env.GITHUB_REPO,
  });
}

async function fetchIssuesWithLabel(octokit: Octokit, owner: string, repo: string, label: string): Promise<BatchIssue[]> {
  const issues: BatchIssue[] = [];
  
  const response = await octokit.issues.listForRepo({
    owner,
    repo,
    labels: label,
    state: "open",
    per_page: 100,
  });

  for (const issue of response.data) {
    // Skip pull requests (they also appear in issues endpoint)
    if (issue.pull_request) {
      continue;
    }

    issues.push({
      number: issue.number,
      title: issue.title,
      url: issue.html_url,
      labels: issue.labels.map((l) => (typeof l === "string" ? l : l.name || "")),
    });
  }

  return issues;
}

export async function handleLabelTrigger(): Promise<LabelTriggerResult> {
  console.log("[batch-trigger] Label trigger initiated");

  try {
    const config = getConfig();
    const octokit = new Octokit({ auth: config.GITHUB_TOKEN });

    console.log(`[batch-trigger] Fetching issues with label: ${config.BATCH_LABEL}`);

    const issues = await fetchIssuesWithLabel(octokit, config.GITHUB_OWNER, config.GITHUB_REPO, config.BATCH_LABEL);

    if (issues.length === 0) {
      console.log("[batch-trigger] No issues found with the specified label");
      return {
        success: true,
        message: `No open issues found with label '${config.BATCH_LABEL}'`,
      };
    }

    console.log(`[batch-trigger] Found ${issues.length} issues with label '${config.BATCH_LABEL}'`);

    // Generate a unique job ID
    const jobId = `batch-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
    const createdAt = new Date().toISOString();

    const job: BatchJobResult = {
      jobId,
      issueCount: issues.length,
      issues,
      url: `https://github.com/${config.GITHUB_OWNER}/${config.GITHUB_REPO}/issues?q=label:${encodeURIComponent(config.BATCH_LABEL)}`,
      createdAt,
    };

    console.log(`[batch-trigger] Created batch job: ${jobId}`);
    console.log(`[batch-trigger] Job URL: ${job.url}`);
    console.log(`[batch-trigger] Issues included: ${issues.map((i) => `#${i.number}`).join(", ")}`);

    return {
      success: true,
      job,
      message: `Successfully created batch job with ${issues.length} issues`,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    console.error(`[batch-trigger] Error: ${errorMessage}`);

    return {
      success: false,
      error: errorMessage,
      message: `Failed to process label trigger: ${errorMessage}`,
    };
  }
}
++ b/src/services/batch-trigger-handler.ts
import { Context } from "probot";
import { getConfig } from "../config/env.js";
import { createClaudeDevJob, ClaudeDevJobResult } from "./claude-dev-api.js";

export interface MilestoneTriggerResult {
  triggered: boolean;
  jobUrl?: string;
  issueCount?: number;
  milestone?: string;
  reason?: string;
}

interface MilestoneIssue {
  number: number;
  title: string;
  html_url: string;
}

/**
 * Handles milestone-based batch triggering of Claude Dev jobs.
 * When an issue is added to a milestone, this function checks if batch processing
 * is enabled and collects all issues in that milestone with the AUTO_DEV_LABEL
 * to create a single batch job.
 */
export async function handleMilestoneTrigger(
  context: Context<"issues.milestoned">
): Promise<MilestoneTriggerResult> {
  const config = getConfig();
  const { owner, repo } = context.repo();
  const issue = context.payload.issue;
  const milestone = issue.milestone;

  context.log.info(
    { owner, repo, issue: issue.number, milestone: milestone?.title },
    "Milestone trigger event received"
  );

  // Check if batch by milestone is enabled
  if (!config.BATCH_BY_MILESTONE) {
    context.log.info("BATCH_BY_MILESTONE is disabled, skipping");
    return {
      triggered: false,
      reason: "BATCH_BY_MILESTONE is disabled",
    };
  }

  // Check if milestone exists
  if (!milestone) {
    context.log.warn("No milestone found on issue");
    return {
      triggered: false,
      reason: "No milestone found on issue",
    };
  }

  const autoDevLabel = config.AUTO_DEV_LABEL;

  // Fetch all open issues in the milestone with the AUTO_DEV_LABEL
  const issuesResponse = await context.octokit.issues.listForRepo({
    owner,
    repo,
    milestone: String(milestone.number),
    labels: autoDevLabel,
    state: "open",
    per_page: 100,
  });

  const milestoneIssues: MilestoneIssue[] = issuesResponse.data
    .filter((i) => !i.pull_request) // Exclude PRs
    .map((i) => ({
      number: i.number,
      title: i.title,
      html_url: i.html_url,
    }));

  context.log.info(
    {
      milestone: milestone.title,
      issueCount: milestoneIssues.length,
      issues: milestoneIssues.map((i) => i.number),
    },
    "Found issues in milestone with AUTO_DEV_LABEL"
  );

  // Check if there are any issues to process
  if (milestoneIssues.length === 0) {
    context.log.info("No issues found in milestone with AUTO_DEV_LABEL");
    return {
      triggered: false,
      milestone: milestone.title,
      issueCount: 0,
      reason: `No issues found in milestone '${milestone.title}' with label '${autoDevLabel}'`,
    };
  }

  // Create batch job with all milestone issues
  const jobDescription = `Batch job for milestone: ${milestone.title}\n\nIssues:\n${milestoneIssues
    .map((i) => `- #${i.number}: ${i.title}`)
    .join("\n")}`;

  const jobResult: ClaudeDevJobResult = await createClaudeDevJob({
    repoFullName: `${owner}/${repo}`,
    issueNumber: issue.number, // Use triggering issue as primary
    issueTitle: `[Milestone] ${milestone.title}`,
    issueBody: jobDescription,
    batchIssues: milestoneIssues.map((i) => i.number),
  });

  context.log.info(
    {
      milestone: milestone.title,
      issueCount: milestoneIssues.length,
      jobUrl: jobResult.jobUrl,
    },
    "Batch job created for milestone"
  );

  return {
    triggered: true,
    jobUrl: jobResult.jobUrl,
    issueCount: milestoneIssues.length,
    milestone: milestone.title,
  };
}
++ b/src/router.ts
  defaultConfig,
  JobStatus,
} from "./core/types";
import { BatchTriggerService } from "./core/batch-trigger";
import { Orchestrator } from "./core/orchestrator";
import { TaskRunner } from "./core/task-runner";
import { db } from "./integrations/db";
  console.warn("[Linear] Integration disabled - LINEAR_API_KEY not set");
}

// Initialize batch trigger service
let batchTrigger: BatchTriggerService | null = null;
try {
  batchTrigger = new BatchTriggerService();
  console.log("[BatchTrigger] Service initialized");
} catch (e) {
  console.warn("[BatchTrigger] Service initialization failed:", e);
}
const orchestrator = new Orchestrator();

type Handler = (req: Request) => Promise<Response>;
  return Response.json({ ok: true, message: "Event ignored" });
});

// Configuration for label-based triggers
const BATCH_LABEL = process.env.BATCH_LABEL || "autodev-batch";
const AUTO_DEV_LABEL = defaultConfig.autoDevLabel;
const ENABLE_MILESTONE_TRIGGER = process.env.ENABLE_MILESTONE_TRIGGER === "true";

async function handleIssueEvent(payload: GitHubIssueEvent): Promise<Response> {
  const { action, issue, repository } = payload;


  // SÃ³ processa se for labeled com auto-dev
  if (action === "labeled") {
    const labelAdded = (payload as any).label?.name;
    console.log(`[Webhook] Label added: "${labelAdded}" on issue #${issue.number}`);

    // Check for batch label trigger
    if (labelAdded === BATCH_LABEL) {
      console.log(`[Webhook] BATCH_LABEL detected on issue #${issue.number}`);
      
      if (!batchTrigger) {
        console.error("[Webhook] BatchTriggerService not available");
        return Response.json({ 
          ok: false, 
          message: "Batch trigger service not available" 
        }, { status: 503 });
      }

      try {
        const result = await batchTrigger.triggerFromLabel(
          repository.full_name,
          issue.number,
          BATCH_LABEL
        );

        console.log(`[Webhook] Batch trigger result: jobId=${result.jobId}, issueCount=${result.issueCount}`);

        return Response.json({
          ok: true,
          message: `Job created with ${result.issueCount} issues`,
          jobId: result.jobId,
          issueCount: result.issueCount,
          dashboardUrl: result.dashboardUrl,
        });
      } catch (error) {
        console.error(`[Webhook] Batch trigger failed:`, error);
        return Response.json({
          ok: false,
          message: "Failed to create batch job",
          error: error instanceof Error ? error.message : String(error),
        }, { status: 500 });
      }
    }

    // Check for milestone-based trigger (if enabled)
    if (ENABLE_MILESTONE_TRIGGER && labelAdded === AUTO_DEV_LABEL && issue.milestone) {
      console.log(`[Webhook] Milestone trigger: AUTO_DEV_LABEL on issue #${issue.number} with milestone "${issue.milestone.title}"`);
      
      if (batchTrigger) {
        try {
          const result = await batchTrigger.triggerFromMilestone(
            repository.full_name,
            issue.milestone.title
          );

          console.log(`[Webhook] Milestone trigger result: jobId=${result.jobId}, issueCount=${result.issueCount}`);

          // Continue to also process the individual issue below
          // The milestone trigger creates a job for all issues in the milestone
        } catch (error) {
          // Log but don't fail - still process the individual issue
          console.error(`[Webhook] Milestone trigger failed (continuing with single issue):`, error);
        }
      }
    }

    // Standard auto-dev label handling for individual issues
    const hasAutoDevLabel = issue.labels.some((l) => l.name === AUTO_DEV_LABEL);

    if (!hasAutoDevLabel) {
      return Response.json({ ok: true, message: "Not an auto-dev issue" });