/**
 * GitHub Integration for IssueBreakdownAgent
 *
 * Handles creating XS subtask issues on GitHub and linking them
 * to the parent issue.
 */

import { GitHubClient } from "../../integrations/github";
import type {
  XSIssueDefinition,
  BreakdownOutput,
  DependencyGraph,
} from "./types";

// =============================================================================
// TYPES
// =============================================================================

export interface CreatedIssue {
  number: number;
  url: string;
  title: string;
  subtaskId: string;
}

export interface BreakdownResult {
  parentIssueNumber: number;
  createdIssues: CreatedIssue[];
  dependencyGraph: DependencyGraph;
  executionPlan: string[];
}

// =============================================================================
// ISSUE CREATION
// =============================================================================

/**
 * Create XS subtask issues on GitHub
 */
export async function createSubtaskIssues(
  github: GitHubClient,
  repoFullName: string,
  parentIssueNumber: number,
  breakdownOutput: BreakdownOutput,
): Promise<BreakdownResult> {
  const createdIssues: CreatedIssue[] = [];

  // Create each XS issue
  for (const issueDef of breakdownOutput.issues) {
    const created = await createSingleIssue(github, repoFullName, issueDef);
    createdIssues.push(created);
  }

  // Add summary comment to parent issue
  await addBreakdownSummary(
    github,
    repoFullName,
    parentIssueNumber,
    createdIssues,
    breakdownOutput,
  );

  // Add labels to parent issue indicating it's been broken down
  await github.addLabels(repoFullName, parentIssueNumber, [
    "broken-down",
    `subtasks-${createdIssues.length}`,
  ]);

  return {
    parentIssueNumber,
    createdIssues,
    dependencyGraph: breakdownOutput.dependencies,
    executionPlan: breakdownOutput.executionPlan,
  };
}

async function createSingleIssue(
  github: GitHubClient,
  repoFullName: string,
  issueDef: XSIssueDefinition,
): Promise<CreatedIssue> {
  const { owner, repo } = github.parseRepo(repoFullName);

  const response = await github.octokit.rest.issues.create({
    owner,
    repo,
    title: issueDef.title,
    body: issueDef.body,
    labels: issueDef.labels,
  });

  return {
    number: response.data.number,
    url: response.data.html_url,
    title: issueDef.title,
    subtaskId: issueDef.metadata.subtaskId,
  };
}

// =============================================================================
// SUMMARY COMMENT
// =============================================================================

async function addBreakdownSummary(
  github: GitHubClient,
  repoFullName: string,
  parentIssueNumber: number,
  createdIssues: CreatedIssue[],
  breakdownOutput: BreakdownOutput,
): Promise<void> {
  const comment = generateSummaryComment(createdIssues, breakdownOutput);

  await github.addComment(repoFullName, parentIssueNumber, comment);
}

function generateSummaryComment(
  createdIssues: CreatedIssue[],
  breakdownOutput: BreakdownOutput,
): string {
  const lines: string[] = [
    "## Issue Breakdown Summary",
    "",
    `This issue has been automatically broken down into **${createdIssues.length} XS subtasks**.`,
    "",
    "### Subtasks",
    "",
  ];

  // List all subtasks with checkboxes
  for (const issue of createdIssues) {
    lines.push(`- [ ] #${issue.number} - ${issue.title}`);
  }

  lines.push("");
  lines.push("### Execution Plan");
  lines.push("");

  for (const step of breakdownOutput.executionPlan) {
    lines.push(`1. ${step}`);
  }

  lines.push("");
  lines.push("### Complexity Analysis");
  lines.push("");
  lines.push(
    `- **Original complexity**: ${breakdownOutput.totalComplexity.original}`,
  );
  lines.push(
    `- **Total estimated lines**: ~${breakdownOutput.totalComplexity.estimatedTotalLines}`,
  );
  lines.push(
    `- **Subtask count**: ${breakdownOutput.totalComplexity.subtaskCount}`,
  );

  lines.push("");
  lines.push("---");
  lines.push("*Generated by AutoDev IssueBreakdownAgent*");

  return lines.join("\n");
}

// =============================================================================
// DEPENDENCY TRACKING
// =============================================================================

/**
 * Update subtask issue with dependency links
 */
export async function linkDependencies(
  github: GitHubClient,
  repoFullName: string,
  createdIssues: CreatedIssue[],
  dependencyGraph: DependencyGraph,
): Promise<void> {
  // Build a map from subtaskId to issue number
  const subtaskToIssue = new Map<string, number>();
  for (const issue of createdIssues) {
    subtaskToIssue.set(issue.subtaskId, issue.number);
  }

  // For each edge in the dependency graph, add a comment
  for (const edge of dependencyGraph.edges) {
    const fromIssue = subtaskToIssue.get(edge.from);
    const toIssue = subtaskToIssue.get(edge.to);

    if (fromIssue && toIssue) {
      // Add "blocks" comment to the dependency
      await github.addComment(
        repoFullName,
        fromIssue,
        `> **Note**: This task blocks #${toIssue}`,
      );

      // Add "depends on" comment to the dependent
      await github.addComment(
        repoFullName,
        toIssue,
        `> **Note**: This task depends on #${fromIssue}`,
      );
    }
  }
}

// =============================================================================
// STATUS TRACKING
// =============================================================================

export interface SubtaskStatus {
  issueNumber: number;
  subtaskId: string;
  state: "open" | "closed";
  hasAutoDevLabel: boolean;
}

/**
 * Check the status of all subtasks for a parent issue
 */
export async function getSubtasksStatus(
  github: GitHubClient,
  repoFullName: string,
  parentIssueNumber: number,
): Promise<SubtaskStatus[]> {
  // Find issues that reference this parent
  const { owner, repo } = github.parseRepo(repoFullName);

  const response = await github.octokit.rest.issues.listForRepo({
    owner,
    repo,
    labels: `subtask-chunk`,
    state: "all",
    per_page: 100,
  });

  // Filter to issues that are subtasks of this parent
  const subtasks = response.data.filter((issue) => {
    // Check if body contains reference to parent issue
    return issue.body?.includes(`from #${parentIssueNumber}`);
  });

  return subtasks.map((issue) => {
    // Extract subtaskId from labels
    const subtaskLabel = issue.labels.find((l) => {
      const name = typeof l === "string" ? l : l.name;
      return name?.startsWith("subtask-");
    });
    const subtaskId =
      typeof subtaskLabel === "string"
        ? subtaskLabel.replace("subtask-", "")
        : subtaskLabel?.name?.replace("subtask-", "") || "";

    const hasAutoDevLabel = issue.labels.some((l) => {
      const name = typeof l === "string" ? l : l.name;
      return name === "auto-dev";
    });

    return {
      issueNumber: issue.number,
      subtaskId,
      state: issue.state as "open" | "closed",
      hasAutoDevLabel,
    };
  });
}

/**
 * Check if all subtasks are complete
 */
export async function areAllSubtasksComplete(
  github: GitHubClient,
  repoFullName: string,
  parentIssueNumber: number,
): Promise<boolean> {
  const statuses = await getSubtasksStatus(
    github,
    repoFullName,
    parentIssueNumber,
  );

  return statuses.length > 0 && statuses.every((s) => s.state === "closed");
}

/**
 * Get next subtask to process (respecting dependencies)
 */
export async function getNextSubtask(
  github: GitHubClient,
  repoFullName: string,
  parentIssueNumber: number,
  dependencyGraph: DependencyGraph,
): Promise<SubtaskStatus | null> {
  const statuses = await getSubtasksStatus(
    github,
    repoFullName,
    parentIssueNumber,
  );

  // Find open subtasks
  const openSubtasks = statuses.filter((s) => s.state === "open");

  if (openSubtasks.length === 0) {
    return null;
  }

  // Find subtasks whose dependencies are all closed
  const closedIds = new Set(
    statuses.filter((s) => s.state === "closed").map((s) => s.subtaskId),
  );

  for (const subtask of openSubtasks) {
    // Get dependencies for this subtask
    const deps = dependencyGraph.edges
      .filter((e) => e.to === subtask.subtaskId)
      .map((e) => e.from);

    // Check if all dependencies are closed
    const allDepsClosed = deps.every((d) => closedIds.has(d));

    if (allDepsClosed && !subtask.hasAutoDevLabel) {
      return subtask;
    }
  }

  return null;
}
